
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <sys/time.h>

#define WAIT 4000

int fd;

struct timeval lasttv;
struct timeval newtv;

void inline ssleep(const int usec) {
   gettimeofday(&lasttv, NULL);
   while (1) {
      gettimeofday(&newtv, NULL);
      if (((newtv.tv_usec - lasttv.tv_usec) + ((newtv.tv_sec - lasttv.tv_sec)*1000000)) > usec) {
         break;
      }
   }
}

void write_command_packet_buf(unsigned char one, unsigned char two, int uwait, int nread, unsigned char* buf, int len) {
	int n, i, j;
	unsigned char buffer[256];
	
	buffer[0] = one;
	buffer[1] = two;
	buffer[2] = 0x04 + len;
	buffer[3] = 0x00;

	for (i = 0; i < len; i++) {
		buffer[i+4] = buf[i];
	}

	n = write(fd, buffer, 4 + len);

	printf("w: n=%d : ", n);

	for (i = 0; i < (4 + len); i++) {
		printf("%x ", (unsigned int)buffer[i]);
	}

	printf("\n");
	
	ssleep(WAIT);

	for (j = 0; j < nread; j++) {
		n = read(fd, buffer, 256);
	
		printf("r: n=%d %s: ", n, (n == -1) ? strerror(errno) : "");

/*		if ((n == -1) && (errno == EAGAIN)) {
			ssleep(2000);
			j--;
		}*/
	
		for (i = 0; i < n; i++) {
			printf("%x ", (unsigned int)buffer[i]);
		}
	
		printf("\n");

		ssleep(WAIT);
	}

	if (uwait > 0) {
		usleep(uwait);
	}
}

inline void write_command_packet(unsigned char one, unsigned char two, int uwait, int nread) {
	write_command_packet_buf(one, two, uwait, nread, NULL, 0);
}

void idle(int n) {
	int i;
	for (i = 0; i < n; i++) {
		write_command_packet(0xa0, 0xa0, 0, 2);
		write_command_packet(0xa1, 0xa0, 1000000, 2);
	}
}

void wait(int n) {
	int i;
	for (i = 0; i < n; i++) {
		write_command_packet(0xa0, 0xe0, 0, 1);
		write_command_packet(0xa1, 0xa0, 200000, 2);
	}
}

void senddata() {
	static const unsigned char band1[] = {
		0x40, 0xbf, 0xb8, 0x00, 0xbf, 0xb8, 0x00, 0xaa, 0x90, 0x00, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
		0x78, 0xff, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
		0x41, 0x41, 0x41, 0x41, 0x41, 0xbf, 0xb8, 0x00, 0x41, 0x41, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
		0xf9, 0xff, 0x80, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0xbf, 0xb8, 0x00, 0x41, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
		0x41, 0x41, 0x41, 0x41, 0x41};
	static const int band1len = 121;	

	static const unsigned char band[] = {
		0x40, 0xbf, 0xb8, 0x00, 0xbf, 0xb8, 0x00, 0xaa, 0x90, 0x00, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
		0x41, 0x41, 0x41, 0x41,	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,	0x41, 0x41, 
		0x41, 0x41, 0x41, 0x40};
	static const int bandlen = 114;

	static const unsigned char endband[38] = {
		0x40, 0xbf, 0xb8, 0x00, 0xbf, 0xb8, 0x00, 0xaa, 0x90, 0x00, 
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
		0x41, 0x41, 0x41, 0x41, 0x40, 0xbf, 0xb8, 0x00, 0xbf, 0xb8, 
		0x00, 0xaa, 0x90, 0x00, 0x41, 0x41, 0x40, 0x42};
	static const int endbandlen = 38;

	unsigned char data[4096];

	int i, j, n, w;

	data[0] = 0xa0;
	data[1] = 0xc0;
	data[2] = band1len-(0x1d+0x39);
	data[3] = 0x1d;

	i = 4;

	for (j = 0; j < band1len; j++) {
		data[i] = band1[j];
		i++;
		if (i == 4096) {
			w = write(fd, data, 4096);
			printf("w: n=%d/%d %s\n", w, 4096, (w == -1) ? strerror(errno) : "");
			i = 0;
			ssleep(WAIT);
		}
	}

	for (n = 1; n < 65; n++) {
		for (j = 0; j < bandlen; j++) {
			data[i] = band[j];
			i++;
			if (i == 4096) {
				w = write(fd, data, 4096);
				printf("w: n=%d/%d %s\n", w, 4096, (w == -1) ? strerror(errno) : "");
				i = 0;
				ssleep(WAIT);
			}
		}
	}
	
	for (j = 0; j < endbandlen; j++) {
		data[i] = endband[j];
		i++;
		if (i == 4096) {
			w = write(fd, data, 4096);
			printf("w: n=%d/%d %s\n", w, 4096, (w == -1) ? strerror(errno) : "");
			i = 0;
			ssleep(WAIT);
		}
	}

	if (i > 0) {
		w = write(fd, data, i);
		printf("w: n=%d/%d %s\n", w, i, (w == -1) ? strerror(errno) : "");
		ssleep(WAIT);
	}
}

int main(int argc, char** argv) {
	fd = open("/dev/usb/lp0", O_RDWR | O_NONBLOCK);

	write_command_packet(0xa1, 0xa1, 0, 2);

	idle(5);

/*	return 0;*/

	write_command_packet(0xa0, 0xa2, 0, 1);
	write_command_packet(0xa0, 0xe0, 0, 1);
	write_command_packet(0xa1, 0xa0, 0, 2);
	write_command_packet(0xa4, 0xe0, 0, 1);

	{
		unsigned char buf[] = {0xee, 0xdb, 0xea, 0xad, 0x00, 0x00, 0x00, 0x00};
		write_command_packet_buf(0xa5, 0xe0, 0, 1, (unsigned char*)&buf, 8);
	}

	write_command_packet(0xa0, 0xe0, 0, 1);
	write_command_packet(0xa0, 0xa0, 0, 2);
	write_command_packet(0xa1, 0xa0, 0, 2);
	write_command_packet(0xa0, 0xe0, 0, 1);
	
	{
		unsigned char buf[] = {
			0x00, 0x00, 0xa4, 0x01, 0x02, 0x01, 0x00, 0x00, 0x1f, 0x1f, 
			0x1f, 0x1f,	0x00, 0x11, 0x03, 0x01, 0x01, 0x01, 0x02, 0x00, 
			0x00, 0x00, 0x70, 0x00, 0x78, 0x00, 0x50, 0x02, 0x7a, 0x1a, 
			0x60, 0x13, 0x67, 0x1b};
		write_command_packet_buf(0xa0, 0xd0, 0, 0, (unsigned char*)&buf, 34);
	}
	write_command_packet(0xa0, 0xe0, 0, 1);
	write_command_packet(0xa1, 0xd0, 0, 0);
	write_command_packet(0xa0, 0xe0, 0, 1);
	write_command_packet(0xa0, 0xa0, 0, 2);

	senddata();

	write_command_packet(0xa0, 0xe0, 0, 1);
	write_command_packet(0xa2, 0xd0, 0, 0);
	write_command_packet(0xa0, 0xe0, 0, 1);
	write_command_packet(0xa1, 0xa0, 0, 2);

	wait(WAIT);

	idle(5);

	close(fd);

	return 0;
}

